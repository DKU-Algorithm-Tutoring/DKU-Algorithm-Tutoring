## :star: Sort

### 정렬 알고리즘 개요

`정렬`이란 **데이터를 특정한 기준에 따라서 순서대로 나열**하는 것을 말한다. 프로그램에서 데이터를 가공할 때 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많기에 정렬 알고리즘은 **프로그램을 작성할 때 가장 많이 사용되는 알고리즘 중 하나다.**

### 선택 정렬

데이터가 무작위로 여러 개 있을 때, **이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정이다.** 쉽게 말해 매번 **'가장 작은 것을 선택'** 한다는 의미에서 `선택 정렬(Selection Sort)` 알고리즘이라고 한다.

선택 정렬의 시간복잡도는 O(N<sup>2</sup>)이다. 하지만 파이썬에 내장된 기본 정렬 라이브러리는 내부적으로 `C언어` 기반이며, 다양한 최적화와 테크닉이 포함되어 더욱 빠르게 동작한다. 선택 정렬은 기본 정렬 라이브러리를 포함해 뒤에서 다룰 알고리즘과 비교했을 때 매우 비효율적이다. 다만, 특정한 리스트에서 **가장 작은 데이터**를 찾는 일이 코딩 테스트에서 잦으므로 선택 정렬 소스코드 형태에 익숙해질 필요가 있다. 

### 삽입 정렬

위에서 설명한 선택 정렬은 알고리즘 문제 풀이에 사용하기에는 느린 편이다. 그렇다면 다른 접근 방법에 대해서 생각해봐야 한다.

```
데이터를 하나씩 확인하며, 각 데이터를 적절한 위치에 삽입하면 어떨까?
```

`삽입 정렬`은 선택 정렬처럼 동작 원리를 직관적으로 이해하기 쉬운 알고리즘이다. 물론 삽입 정렬은 선택 정렬에 비해 구현 난이도가 높은 편이지만, 선택 정렬에 비해 **실행 시간 측면에서 더 효율적인 알고리즘**으로 잘 알려져 있다.

`삽입 정렬(Insertion Sort)`은 특정한 데이터를 적절한 위치에 '삽입' 한다는 의미에서 삽입 정렬이라고 부른다. 삽입 정렬의 시간복잡도는 선택 정렬과 마찬가지로 O(N<sup>2</sup>)인데, 실제로 수행 시간을 테스트해보면 앞서 다루었던 선택 정렬과 흡사한 시간이 소요되는 것을 알 수 있다. 여기서 꼭 기억할 내용은 삽입 정렬은 현재 리스트의 데이터가 **거의 정렬되어 있는 상태**라면 매우 빠르게 동작한다는 점이다. 최선의 경우에는 O(N)의 시간 복잡도를 가진다.

### 퀵 정렬

`퀵 정렬`은 지금까지 배운 정렬 알고리즘 중에서 **가장 많이 사용되는 알고리즘**이다. 퀵 정렬은 **기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작**한다. 이해하기까지 시간이 걸리겠지만 원리를 이해하면 `병합 정렬`, `힙 정렬` 등 다른 고급 정렬 기법에 비해 쉽게 소스코드를 작성할 수 있다.

#### Python Quick Sort Code

```
def quick_sort(array):
    if len(array) <= 1:
        return

    pivot = array[0]
    tail = array[1:]

    left_side = [x for x in tail if x < pivot]
    right_side = [x for x in tail if x > pivot]

    return quick_sort(left_side) + quick_sort(right_side)


array = list(map(int, input().split()))

print(quick_sort(array))
```

퀵 정렬의 평균 시간복잡도는 O(NlogN)이다. 앞서 배웠던 두 정렬에 비해 빠른 시간복잡도를 갖는다. 하지만, 리스트의 가장 왼쪽 데이터를 피벗으로 삼을 때, **이미 데이터가 정렬 되어 있는 경우**에는 매우 느리게 동작한다.

### 계수 정렬

`계수 정렬` 알고리즘은 **특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘**이다. 모든 데이터가 양의 정수인 상황이며, 데이터의 개수가 N, 데이터 중 최대값이 K일 때, 최악의 경우에도 수행시간 O(N + K)를 보장한다. 계수 정렬은 **데이터의 크기 범위가 제한 되어 정수 형태로 표편할 수 있을 때**만 사용이 가능하다.

```
array = list(map(int, input().split()))

count = [0] * (max(array) + 1)

for i in array:
    count[i] += 1

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ')
```

계수 정렬은 때에 따라서 심각한 비효율성을 초래할 수 있다. 다시 말해 계수 정렬은 데이터의 크기가 한정 되어 있고, 데이터의 크기가 많이 중복되어 있을수록 유리하며 항상 사용할 수는 없다.

### 파이썬의 정렬 라이브러리

파이썬은 기본 정렬 라이브러리인 `sorted`와 `sort` 라이브러리 함수를 제공한다. 두 라이브러리는 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 병합 정렬은 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간복잡도 O(NlogN)을 보장한다는 특징이 있다. sorted와 sort의 차이점은 한 번 찾아보는 것이 좋을 것이다.

### 코딩테스트에서의 정렬

- 정렬 라이브러리로 풀 수 있는 문제 : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
- 정렬 알고리즘의 원리에 대해서 물어보는 문제 : 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
- 더 빠른 정렬이 필요한 문제 : 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.


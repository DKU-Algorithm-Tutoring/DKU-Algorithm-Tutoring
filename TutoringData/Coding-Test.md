## 2021년 알고리즘 튜터링 코딩 테스트

문제는 보관만 가능하고, 유출하지 맙시다.!

문제는 총 8문제이며 정확성만 검사하는 문제도 있고 효율성까지 검사하는 문제도 있습니다. 그 효율성 테스트 같은 경우는 사이트에서 직접 효율성 검사를 하는 행위는 금하며 본인이 직접 시간 복잡도와 메모리 공간 효율성을 충분히 생각하시고 계산하여 푸시기를 바랍니다.

테스트 케이스의 경우 본인이 추가해서 하는 행위는 가능하지만, 튜터에게 테스트 케이스를 더 달라는 행위는 금합니다. 또한, 문제에 대한 질문을 받는다고 했는데, 실제 코딩테스트에서 문제에 대한 질문을 금하기 때문에 금하겠습니다.

테스트시간은 총 4시간이며 2시부터 6시까지입니다. 본인이 늦게 들어오면, 늦게 들어온 만큼 시간이 차감됩니다. 문제를 다 풀었으면, 답안지를 개인 카톡으로 제출하고, 퇴장하면 됩니다. 또한, 한 번 제출 후 수정 불가능하니 신중히 제출해주시길 바랍니다.

앞서 공지 했듯이, 구글 검색까지는 허용하나, 책을 찾아보거나 친구들과 공유하는 행위는 본인의 실력을 망치는 길이니 주의하세요. 만약 채점 시에 비슷한 코드가 있으면, 전체 0점 처리 하겠습니다.

점수 채점은 튜터가 직접 진행하며 (그러다 보니 채점이 오래 걸릴 수 있음.), 백준이나 프로그래머스에 올라간 문제가 아니기 때문에 본인이 생각하기에 맞는 것 같을 때는, 질문하길 바람.

문제지와 정답지는 따로 있으며, 정답지에 정답을 작성하는 예시가 있으니 예시에 맞게 코드를 작성해서 제출해주고, 제출 양식에 맞지 않으면, 해당 문제는 0점 처리하겠습니다.

정답지는 시험이 끝난 후에 공개하지 않으며, 본인이 풀었던 문제에 대한 점수만 공개하겠습니다. 하지만 시험이 끝난 후에 틀린 문제에 대한 정답을 채점 해달라는 경우는 채점을 해드리도록 하겠습니다.

실제 코딩테스트도 아니고, 학교 시험도 아니지만, 여러분이 실제 시험처럼 보시길 바라는 마음에 최대한 시험처럼 시행하려고 하는 것이며, 가벼운 마음으로 풀지 않았으면 좋겠습니다. 그리고 실제 코딩테스트에선 카피나 공유하는 행위가 절대적으로 불가능하니, 연습하는 겸사겸사 혼자 풀어보는 연습을 해보시길 바랍니다.

시험 잘 보시길 바랍니다.


## 문제 1.

컴퓨터에 있는 디렉토리에 파일이 너무 많아져서 2번 이상 중복된 파일을 찾으려고 합니다.
문자열로 이루어진 파일명을 담은 배열 param0이 매개변수로 주어집니다.
다음 조건에 맞는 파일들 중에 중복된 파일 이름의 원본 파일명을 찾아서, 중복 개수와 함께 배열을 담아 return하도록 solution 함수를 작성해주세요.

- 디렉토리 이름이나 파일 이름은 알파벳 소문자 a-z중에 하나로 이뤄집니다.
- 파일 이름에는 .a 부터 .z까지 확장자(한 글자)가 붙습니다. (예: `a.a`, `b.e`, `c.z`)
- 디렉토리 내부에는 `/a/b/`, `/a/c/b/` 처럼 다른 디렉토리가 포함될 수 있습니다.
- 파일 이름 뒤에는 `_v1`, `_v2`, …, `_v9` 까지 최대 9종류의 버전을 추가로 붙일 수 있습니다.
- 버전 정보는 선택사항이라 `a.z` 파일과 `a_v1.z`, `a_v9.z` 파일은 같은 파일로 인식합니다.
- 원본 파일명은 버전 정보가 포함되지 않은 파일명입니다.

### Limit

- 입력값에는 반드시 파일명이 존재합니다. 대신 버전 정보는 생략 가능합니다.
- 디렉토리 깊이는 0단계 이상, 10단계 이하입니다. 예를 들어 `/a.z`는 0단계, `/a/a.z`는 1단계의 디렉토리 깊이를 가집니다.
- 입력값 파일명은 0개 이상, 100개 이하입니다.
- 출력 파일명 순서는 입력 파일명 순서를 보장해야 합니다.

### TestCase

1. 입력값 ["/a/a_v2.x", "/b/a.x", "/c/t.z", "/d/a/t.x", "/e/z/t_v1.z", "/k/k/k/a_v9.x"]

==> return ["a.x", "3", "t.z", "2"]

2. 입력값 ["/t.z", "/z/z_v2.z", "/a.z", "/d/b.z", "/d/a/t.z"]

==> return ["t.z", "2"]

3. 입력값 ["/t.z", "/b/b.z", "/a.z", "/e/k.z", "/d/a/x_v2.z"]

==> return []

```
def solution(param0):
    answer = []
    return answer
```

## 문제 2.

팩토리얼은 자연수 n에 대해 1부터 n까지 모든 숫자를 곱하는 것을 의미하며 n 팩토리얼은 n!라고 표기합니다. 예를들어 3!은 1 x 2 x 3 = 6입니다.

그리고 n!을 계산했을 때 가장 낮은 자리부터 연속되어 나타나는 0의 개수를 팩토리얼 꼬리의 길이라고 합니다.

예를들어 n = 10인 경우 10!은 3628800이며 가장 낮은 자리부터 연속해서 2개의 0이 잇으므로 팩토리얼 꼬리의 길이는 2입니다.

입력으로 n이 주어질 때 팩토리얼 꼬리의 길이를 반환하는 함수를 완성해 주세요.

### Limit

- n은 2<sup>31</sup> - 1 이하의 자연수입니다.
- 해당 문제는 효율성 테스트도 거칩니다.

### TestCase

n | result
:--- | :---
5 | 1
10 | 2

```
def solution(n):
    answer = 0
    return answer
```


## 문제 3.

좋은 부분 문자열이란 어떤 문자열 s의 부분 문자열이면서 같은 알파벳이 두 번 이상 나타나지 않는 문자열을 말합니다. 예를 들어 주어진 문자열이 "abac"일 때, 부분 문자열 "a", "ab", "bac" 등은 원래 문자열 "abac"의 부분 문자열이면서 문자열 내에 같은 알파벳이 두 번 이상 나타나지 않으므로 좋은 부분 문자열입니다. 그러나 "aba", "abac"는 문자열 내에 같은 알파벳 'a'가 두 번 이상 나타나므로 좋은 부분 문자열이 아닙니다. 문자열 s가 주어질 때 좋은 부분 문자열의 개수를 return 하도록 solution 함수를 완성해주세요.

### Limit

- 문자열 s의 길이는 1 이상 100 이하이며, 알파벳 소문자로만 이루어져 있습니다.
- 여러 번 나타나는 같은 부분 문자열은 하나로 세면 됩니다.

### TestCase

s | result
:--- | :---
"abac" | 7
"abcd" | 10

```
def solution(s):
    answer = 0
    return answer
```

## 문제 4.

한 번에 최대 N잔까지 동시에 커피를 추출할 수 있는 커피 추출기가 있습니다. 이 커피 추출기를 이용해 커피를 만들 때, 커피가 만들어지는 순서를 구하려 합니다.

만들어야 하는 커피가 M잔이면, 커피에 1부터 M까지 순서대로 주문번호가 붙어있습니다. 또, 주문번호 순으로 빈 커피 추출구에서 커피를 만들기 시작합니다. 만약 빈 추출구가 없다면, 빈 추출구가 생길 때까지 다음 주문은 잠시 기다리며, 빈 추출구가 생기면 대기 중인 다음 커피를 즉시 만들기 시작합니다.

모든 커피는 만드는데 일정 시간이 소요되는데, 소요 시간은 커피 종류별로 다를 수 있습니다. 따라서 커피 제조 시간에 따라 각 주문이 완료되는 순서는 다를 수 있습니다.

커피 추출구 개수 N, 각 커피를 만드는데 걸리는 시간이 주문번호 순서대로 담긴 배열 coffee_times가 매개변수로 주어질 때, 커피가 완성되는 순서대로 주문번호를 배열에 담아 return 하도록 solution 함수를 완성해주세요.

단, 커피 주문에 추출구에 배정되는데 걸리는 시간은 없다고 가정하며, 커피 추출이 동시에 완료됐을 경우 작은 주문번호가 앞에 오도록 하면 됩니다.

### Limit

- N은 1이상 10,000 이하인 자연수입니다.
- coffee_times의 길이는 1 이상 300,000 이하입니다.
- coffee_times의 원소는 1 이상 100,000,000 이하인 자연수입니다.

### TestCase

N | coffee_times | result
:--- | :--- | :---
3 | [4, 2, 2, 5, 3] | [2, 3, 1, 5, 4]
1 | [100, 1, 50, 1, 1] | [1, 2, 3, 4, 5]

```
def solution(N, coffee_times):
    answer = []
    return answer
```

## 문제 5.

스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.

![](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4b69a271-5f4a-4bf4-9ebf-6ebed5a02d8d/kakao_phone1.png)

이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.
맨 처음 왼손 엄지손가락은 `*` 키패드에 오른손 엄지손가락은 `#` 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.
- 엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.
- 왼쪽 열의 3개의 숫자 `1`, `4`, `7`을 입력할 때는 왼손 엄지손가락을 사용합니다.
- 오른쪽 열의 3개의 숫자 `3`, `6`, `9`를 입력할 때는 오른손 엄지손가락을 사용합니다.
- 가운데 열의 4개의 숫자 `2`, `5`, `8`, `0`을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.
    - 만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.

순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.

### Limit

- numbers 배열의 크기는 1 이상 1,000 이하입니다.
- numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다.
- hand는 "left" 또는 "right" 입니다.
    - "left"는 왼손잡이, "right"는 오른손잡이를 의미합니다.
- 왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.

### TestCase

numbers | 	hand |	result
:--- | :--- | :---
[1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] |	"right" |	"LRLLLRLLRRL"
[7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2] |	"left" |	"LRLLRRLLLRR"
[1, 2, 3, 4, 5, 6, 7, 8, 9, 0] |	"right" |	"LLRLLRLLRL"

```
def solution(numbers, hand):
    answer = ''
    return answer
```


## 문제 6.

네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.
- 지도는 한 변의 길이가 `n`인 정사각형 배열 형태로, 각 칸은 "공백"(" ") 또는 "벽"("#") 두 종류로 이루어져 있다.
- 전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 "지도 1"과 "지도 2"라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
- "지도 1"과 "지도 2"는 각각 정수 배열로 암호화되어 있다.
- 암호화된 배열은 지도의 각 가로줄에서 벽 부분을 `1`, 공백 부분을 `0`으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.


![](http://t1.kakaocdn.net/welcome2018/secret8.png)

네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.

### Limit

입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.

- 1 ≦ n ≦ 16
- arr1, arr2는 길이 n인 정수 배열로 주어진다.
- 정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.
- 원래의 비밀지도를 해독하여 '#', 공백으로 구성된 문자열 배열로 출력하라.

### TestCase

매개변수 |	값
:--- | :---
n |	5
arr1 |	[9, 20, 28, 18, 11]
arr2 |	[30, 1, 21, 17, 28]
출력 |	["#####","# # #", "### #", "# ##", "#####"]

매개변수 |	값
:--- | :---
n |	6
arr1 |	[46, 33, 33 ,22, 31, 50]
arr2 |	[27 ,56, 19, 14, 14, 10]
출력 |	["######", "### #", "## ##", " #### ", " #####", "### # "]


```
def solution(n, arr1, arr2):
    answer = []
    return answer
```

## 문제 7.

[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

개발자 출신으로 세계 최고의 갑부가 된 `어피치`는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다.

어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.

어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.

`진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매`

예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.

진열대 번호 |	1 |	2 |	3 |	4 |	5 |	6 |	7 |	8
:--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- | :---
보석 이름 |	DIA |	RUBY |	RUBY |	DIA |	DIA |	EMERALD |	SAPPHIRE |	DIA

진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.

진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.

진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.
가장 짧은 구간의 `시작 진열대` 번호와 `끝 진열대 번호`를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 `시작 진열대 번호`가 가장 작은 구간을 return 합니다.


### Limit

- gems 배열의 크기는 1 이상 100,000 이하입니다.
    - gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.
    - gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.
    - gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.

gems |	result
:--- | :---
["DIA", "RUBY", "RUBY", "DIA", "DIA", "EMERALD", "SAPPHIRE", "DIA"]	 |[3, 7]
["AA", "AB", "AC", "AA", "AC"] |	[1, 3]
["XYZ", "XYZ", "XYZ"] |	[1, 1]
["ZZZ", "YYY", "NNNN", "YYY", "BBB"] |	[1, 5]

```
def solution(gems):
    answer = []
    return answer
```

## 문제 8.
[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]

카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.

- 코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다.
- 지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다.
- 지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다.
- 선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다.

인재영입팀에 근무하고 있는 `니니즈`는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.

예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.

`코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?`

물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.

- 코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?
- 코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?
- backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가?
- 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가?
- 코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가?

즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.

```
* [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?
```

지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,
각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.


### Limit

- info 배열의 크기는 1 이상 50,000 이하입니다.
- info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 "개발언어 직군 경력 소울푸드 점수" 형식입니다.
    - 개발언어는 cpp, java, python 중 하나입니다.
    - 직군은 backend, frontend 중 하나입니다.
    - 경력은 junior, senior 중 하나입니다.
    - 소울푸드는 chicken, pizza 중 하나입니다.
    - 점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다.
    - 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.
- query 배열의 크기는 1 이상 100,000 이하입니다.
- query의 각 문자열은 "[조건] X" 형식입니다.
    - [조건]은 "개발언어 and 직군 and 경력 and 소울푸드" 형식의 문자열입니다.
    - 언어는 cpp, java, python, - 중 하나입니다.
    - 직군은 backend, frontend, - 중 하나입니다.
    - 경력은 junior, senior, - 중 하나입니다.
    - 소울푸드는 chicken, pizza, - 중 하나입니다.
    - '-' 표시는 해당 조건을 고려하지 않겠다는 의미입니다.
    - X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다.
    - 각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.
    - 예를 들면, "cpp and - and senior and pizza 500"은 "cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?"를 의미합니다.


### TestCase

info |	query |	result
:--- | :--- | :---
["java backend junior pizza 150","python frontend senior chicken 210","python frontend senior chicken 150","cpp backend senior pizza 260","java backend junior chicken 80","python backend senior chicken 50"] |	["java and backend and junior and pizza 100","python and frontend and senior and chicken 200","cpp and - and senior and pizza 250","- and backend and senior and - 150","- and - and - and chicken 100","- and - and - and - 150"] |	[1,1,1,1,2,4]

지원자 정보를 표로 나타내면 다음과 같습니다.

언어 |	직군 |	경력 |	소울 푸드 |	점수
:--- | :--- | :--- | :--- | :---
java |	backend |	junior |	pizza |	150
python |	frontend |	senior |	chicken |	210
python |	frontend |	senior |	chicken |	150
cpp |	backend |	senior |	pizza |	260
java |	backend |	junior |	chicken |	80
python |	backend |	senior |	chicken |	50

- "java and backend and junior and pizza 100" : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다.
- "python and frontend and senior and chicken 200" : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다.
- "cpp and - and senior and pizza 250" : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다.
- "- and backend and senior and - 150" : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다.
- "- and - and - and chicken 100" : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다.
- "- and - and - and - 150" : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.

```
def solution(info, query):
    answer = []
    query_split = [x.split(' and ') for x in query]
    info_split = [x.split(' ') for x in info]
    last = query_split.pop()
    print(last)
    print(query_split)
    return answer
```
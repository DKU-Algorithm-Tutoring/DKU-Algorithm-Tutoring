Problem
정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 
프로그램을 작성하시오. 예를 들어 1을 입력했을 때 다음은 3이 하나라도 포함되어 있으므로 세어야 하는 시각이다.

- 00시 00분 03초
- 00시 13분 30초

반면에 다음은 3이 하나도 포함되어 있지 않으므로 세면 안 되는 시각이다.

- 00시 02분 55초
- 01시 27분 45초

SourceCode
n=int(input())
count=0
for a in range(n+1):
    for b in range(60):
        for c in range(60):
            if '3' in str(a) or '3' in str(b) or '3' in str(c):
                count+=1
print(count)

Problem
현민이는 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다.
캐릭터가 있는 장소는 1 x 1 크기의 정사각형으로 이뤄진 N x M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다.
캐릭터는 동서남북 중 한 곳을 바라본다.
맵의 각 칸은 (A, B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다.
캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다.
캐릭터의 움직임을 설정하기 위해 정해 놓은 매뉴얼은 이러하다.
    1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향 (반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다.
    2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다.
    왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.
    3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 
    1단계로 돌아간다.
    
    단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.
    
현민이는 위 과정을 반복적으로 수행하면서 캐릭터의 움직임에 이상이 있는지 테스트하려고 한다.
매뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오.
입력 조건
- 첫째 줄에 맵의 세로 크기 N과 가로 크기 M을 공백으로 구분하여 입력한다.
- 둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (A, B)와 바라보는 방향 d가 각각 서로 공백으로 구분하여 주어진다. 방향 d의 값으로는 
다음과 같이 4가지가 존재한다.
    - 0: 북쪽
    - 1: 동쪽
    - 2: 남쪽
    - 3: 서쪽
- 셋째 줄부터 맵이 육지인지 바다인지에 대한 정보가 주어진다. N개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로, 각 줄의 데이터는 
서쪽부터 동쪽 순서대로 주어진다. 맵의 외곽은 항상 바다로 되어 있다.
    - 0: 육지
    - 1: 바다
- 처음에 게임 캐릭터가 위치한 칸의 상태는 항상 육지이다.

SourceCode
n,m=map(int,input().split())
a,b,d=map(int,input().split())
x=a+1
y=b+1
direction=[0,1,2,3]
mapp=[]
sea=[]
for _ in range(m+2):
    sea.append(1)
mapp.append(sea)
for _ in range(n):
    row=[1]
    tmp=list(map(int,input().split()))
    for z in range(m):
        row.append(tmp[z])
    row.append(1)
    mapp.append(row)
mapp.append(sea)
#여기까지가 맵 생성
movecount=1
turncount=0
while True:
    mapp[x][y]=2
    if turncount==4:
        if d == direction[0]:
            if mapp[x][y+1] == 2:
                y = y + 1
                turncount=0
            else:
                break
        elif d == direction[3]:
            if mapp[x+1][y] == 2:
                x = x+ 1
                turncount=0
            else:
                break
        elif d == direction[2]:
            if mapp[x][y-1] == 2:
                y = y- 1
                turncount=0
            else:
                break
        elif d == direction[1]:
            if mapp[x-1][y] == 2:
                x = x- 1
                turncount=0
            else:
                break

    if d==direction[0]:
        if mapp[x-1][y]==0:
            x=x-1
            mapp[x][y]=2
            d=3
            movecount+=1
            turncount=0
        else:
            d=3
            turncount+=1
            continue
    elif d==direction[3]:
        if mapp[x][y+1]==0:
            y=y+1
            mapp[x][y]=2
            d=2
            movecount+=1
            turncount = 0
        else:
            d=2
            turncount+=1
            continue
    elif d == direction[2]:
        if mapp[x+1][y]==0:
            x=x+1
            mapp[x][y]=2
            d=1
            movecount+=1
            turncount = 0
        else:
            d=1
            turncount+=1
            continue
    elif d == direction[1]:
        if mapp[x][y-1]==0:
            y=y-1
            mapp[x][y]=2
            d=0
            movecount+=1
            turncount = 0
        else:
            d=0
            turncount+=1
            continue
print(movecount)
-----------------------------------------------------------------------------------------------------------------------------------------
Problem
각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 대, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어
결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요. 
단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.
예를 들어 02984라는 문자열이 주어지면, 만들어질 수 있는 가장 큰수는 ((((0 + 2) * 9) * 8) * 4) = 576입니다.
또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.

SourceCode
n=input()
result=0
for i in n:
    num=int(i)
    if result+num > result*num:
        result=result+num
    else:
        result=result*num
print(result)

Problem
다솜이는 0과 1로만 이루어진 문자열 S를 가지고 있습니다. 다솜이는 이 문자열 S에 있는 모든 숫자를 전부 같게 만들려고 합니다. 
다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것입니다. 뒤집는것은 1을 0으로, 0을 1로 바꾸는 것을 의미합니다. 
예를들어 S = 0001100일 때는 다음과 같습니다. 
1. 전체를 뒤집으면 1110011이 됩니다. 
2. 4번째 문자부터 5번째 문자까지 뒤집으면 11111111이 되어서 두 번 만에 모두 같은 숫자로 만들 수 있습니다. 
하지만, 처음부터 4번째 문자부터 5번째 문자까지 문자를 뒤집으면 한 번에 00000000이 되어서 1번 만에 모두 같은 숫자로 만들 수 있습니다. 
문자열 S가 주어졌을 때, 다솜이가 해야 하는 행동의 최소 횟수를 출력하세요.

SourceCode
s=input()
save=s[0]
tmp=s[0]
count=0
for i in s:
    if i!=save:
        save=i
        count+=1
if tmp==s[len(s)-1]:
    print(count//2)
else:
    print(count//2+1)

Problem
A, B 두 사람이 볼링을 치고 있습니다. 두 사람은 서로 무게가 다른 볼링공을 고르려고 합니다. 
볼링공은 총 N개가 있으며 각 볼링공마다 무게가 적혀 있고, 공의 번호는 1번부터 순서대로 부여됩니다. 
또한 같은 무게의 공이 여러 개 있을 수 있지만, 서로 다른 공으로 간주합니다. 볼링공의 무게는 1부터 M까지의 자연수 형태로 존재합니다. 
예를 들어 N이 5이고, M이 3이며 각각의 무게가 차례대로 1, 3, 2, 3, 2일 때 각 곡의 번호가 차례대로 1번부터 5번까지 부여됩니다. 
이때 두 사람이 고를 수 있는 볼링공 번호의 조합을 구하면 다음과 같습니다.
(1번, 2번), (1번, 3번), (1번, 4번), (1번, 5번), (2번, 3번), (2번, 5번), (3번, 4번), (4번, 5번)
결과적으로 두 사람이 공을 고르는 경우의 수는 8가지입니다. N개의 공의 무게가 각각 주어질 때, 두 사람이 볼링공을 고르는 경우의 수를 구하는 프로그램을 작성하세요.

SourceCode
n,m=map(int,input().split())
lst=list(map(int,input().split()))
count=0
for i in range(n):
    for u in range(i+1,n):
        if lst[i]!=lst[u]:
            if count!=0:
                print(",",end=" ")
            count += 1
            print("("+str(i+1)+"번, "+str(u+1)+"번)",end="")

Problem
알파벳 대문자와 숫자 (0 ~ 9)로만 구성된 문자열이 입력으로 주어집니다. 
이때 모든 알파벳을 오름차순으로 정렬하여 이어서 출력한 뒤에, 그 뒤에 모든 숫자를 더한 을 이어서 출력합니다. 
예를 들어 K1KA5CB7이라는 값이 들어오면 ABCKK13을 출력합니다.

SourceCode
ipt=input()
lstnum=[]
lstalp=[]
for i in ipt:
    if i.isalpha():
        lstalp.append(i)
    else:
        lstnum.append(int(i))
lstalp.sort()
for i in lstalp:
    print(i,end="")
print(sum(lstnum))

Problem
게임의 아웃복서 캐릭터는 필살기인 '럭키 스트레이트' 기술이 있습니다. 
이 기술은 매우 강력한 대신에 게임 내에서 점수가 특정 조건을 만족할 때만 사용할 수 있습니다. 
특정 조건이란 현재 캐릭터의 점수를 N이라고 할 때 자릿수를 기준으로 점수 N을 반으로 나누어 왼쪽 부분의 각 자릿수의 합과 오른쪽 부분의 각 자릿수의 합을 더한 값이 동일한 상황을 의미합니다. 
예를 들어 현재 점수가 123,402라면 왼쪽 부분의 각 자릿수의 합은 1 + 2 + 3, 오른쪽 부분의 각 자릿수의 합은 4 + 0 + 2 이므로 두 합이 6으로 동일하여 럭키 스트레이트를 사용할 수 있습니다. 
현재 점수 N이 주어지면 럭키 스트레이트를 사용할 수 있는 상티인지 아닌지를 알려주는 프로그램을 작성하세요.

SourceCode
num=int(input())
z=len(str(num))//2
head=num//10**z
tail=num%10**z
total1=0
total2=0
for i in str(head):
    total1+=int(i)
for i in str(tail):
    total2+=int(i)
if total1==total2:
    print("LUCKY")
else:
    print("READY")



풀다가 실패한 문제들
__________________________________
n=int(input())
lst=list(map(int,input().split()))
lst.sort()
print(lst)
group=0
while True:
    num=lst[len(lst)-1]
    if num>len(lst):
        break
    for _ in range(num):
        lst.pop(len(lst)-1)
    group+=1
___________________________________
food=list(map(int,input().split()))
k=int(input())
idx=-1
while True:
    idx += 1
    idx%=len(food)
    if food[idx]==0:
        continue
    food[idx]-=1
    k-=1
    if k==0:
        print(idx-1)
        break
    if food is None:
        print("-1")
        break

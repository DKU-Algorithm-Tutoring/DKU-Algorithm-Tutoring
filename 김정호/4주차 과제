Problem
현민이는 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다.
캐릭터가 있는 장소는 1 x 1 크기의 정사각형으로 이뤄진 N x M 크기의 직사각형으로, 각각의 칸은 육지 또는 바다이다.
캐릭터는 동서남북 중 한 곳을 바라본다.
맵의 각 칸은 (A, B)로 나타낼 수 있고, A는 북쪽으로부터 떨어진 칸의 개수, B는 서쪽으로부터 떨어진 칸의 개수이다.
캐릭터는 상하좌우로 움직일 수 있고, 바다로 되어 있는 공간에는 갈 수 없다.
캐릭터의 움직임을 설정하기 위해 정해 놓은 매뉴얼은 이러하다.
    1. 현재 위치에서 현재 방향을 기준으로 왼쪽 방향 (반시계 방향으로 90도 회전한 방향)부터 차례대로 갈 곳을 정한다.
    2. 캐릭터의 바로 왼쪽 방향에 아직 가보지 않은 칸이 존재한다면, 왼쪽 방향으로 회전한 다음 왼쪽으로 한 칸을 전진한다.
    왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽 방향으로 회전만 수행하고 1단계로 돌아간다.
    3. 만약 네 방향 모두 이미 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 가고 
    1단계로 돌아간다.
    
    단, 이때 뒤쪽 방향이 바다인 칸이라 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.
    
현민이는 위 과정을 반복적으로 수행하면서 캐릭터의 움직임에 이상이 있는지 테스트하려고 한다.
매뉴얼에 따라 캐릭터를 이동시킨 뒤에, 캐릭터가 방문한 칸의 수를 출력하는 프로그램을 만드시오.
입력 조건
- 첫째 줄에 맵의 세로 크기 N과 가로 크기 M을 공백으로 구분하여 입력한다.
- 둘째 줄에 게임 캐릭터가 있는 칸의 좌표 (A, B)와 바라보는 방향 d가 각각 서로 공백으로 구분하여 주어진다. 방향 d의 값으로는 
다음과 같이 4가지가 존재한다.
    - 0: 북쪽
    - 1: 동쪽
    - 2: 남쪽
    - 3: 서쪽
- 셋째 줄부터 맵이 육지인지 바다인지에 대한 정보가 주어진다. N개의 줄에 맵의 상태가 북쪽부터 남쪽 순서대로, 각 줄의 데이터는 
서쪽부터 동쪽 순서대로 주어진다. 맵의 외곽은 항상 바다로 되어 있다.
    - 0: 육지
    - 1: 바다
- 처음에 게임 캐릭터가 위치한 칸의 상태는 항상 육지이다.

SourceCode
n,m=map(int,input().split())
a,b,d=map(int,input().split())
x=a+1
y=b+1
direction=[0,1,2,3]
mapp=[]
sea=[]
for _ in range(m+2):
    sea.append(1)
mapp.append(sea)
for _ in range(n):
    row=[1]
    tmp=list(map(int,input().split()))
    for z in range(m):
        row.append(tmp[z])
    row.append(1)
    mapp.append(row)
mapp.append(sea)
#여기까지가 맵 생성
movecount=1
turncount=0
while True:
    mapp[x][y]=2
    if turncount==4:
        if d == direction[0]:
            if mapp[x][y+1] == 2:
                y = y + 1
                turncount=0
            else:
                break
        elif d == direction[3]:
            if mapp[x+1][y] == 2:
                x = x+ 1
                turncount=0
            else:
                break
        elif d == direction[2]:
            if mapp[x][y-1] == 2:
                y = y- 1
                turncount=0
            else:
                break
        elif d == direction[1]:
            if mapp[x-1][y] == 2:
                x = x- 1
                turncount=0
            else:
                break

    if d==direction[0]:
        if mapp[x-1][y]==0:
            x=x-1
            mapp[x][y]=2
            d=3
            movecount+=1
            turncount=0
        else:
            d=3
            turncount+=1
            continue
    elif d==direction[3]:
        if mapp[x][y+1]==0:
            y=y+1
            mapp[x][y]=2
            d=2
            movecount+=1
            turncount = 0
        else:
            d=2
            turncount+=1
            continue
    elif d == direction[2]:
        if mapp[x+1][y]==0:
            x=x+1
            mapp[x][y]=2
            d=1
            movecount+=1
            turncount = 0
        else:
            d=1
            turncount+=1
            continue
    elif d == direction[1]:
        if mapp[x][y-1]==0:
            y=y-1
            mapp[x][y]=2
            d=0
            movecount+=1
            turncount = 0
        else:
            d=0
            turncount+=1
            continue
print(movecount)
-----------------------------------------------------------------------------------------------------------------------------------------
Problem
각 자리가 숫자(0부터 9)로만 이루어진 문자열 S가 주어졌을 대, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어
결과적으로 만들어질 수 있는 가장 큰 수를 구하는 프로그램을 작성하세요. 
단, +보다 x를 먼저 계산하는 일반적인 방식과는 달리 모든 연산은 왼쪽에서부터 순서대로 이루어진다고 가정합니다.
예를 들어 02984라는 문자열이 주어지면, 만들어질 수 있는 가장 큰수는 ((((0 + 2) * 9) * 8) * 4) = 576입니다.
또한 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 입력이 주어집니다.

SourceCode
n=input()
result=0
for i in n:
    num=int(i)
    if result+num > result*num:
        result=result+num
    else:
        result=result*num
print(result)

풀다가 실패한 문제들
__________________________________
n=int(input())
lst=list(map(int,input().split()))
lst.sort()
print(lst)
group=0
while True:
    num=lst[len(lst)-1]
    if num>len(lst):
        break
    for _ in range(num):
        lst.pop(len(lst)-1)
    group+=1
___________________________________

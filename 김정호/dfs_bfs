ðŸ’¬ ìŒë£Œìˆ˜ ì–¼ë ¤ ë¨¹ê¸°
N x M í¬ê¸°ì˜ ì–¼ìŒ í‹€ì´ ìžˆë‹¤. êµ¬ë©ì´ ëš«ë ¤ ìžˆëŠ” ë¶€ë¶„ì€ 0, ì¹¸ë§‰ì´ê°€ ì¡´ìž¬í•˜ëŠ” ë¶€ë¶„ì€ 1ë¡œ í‘œì‹œëœë‹¤. 
êµ¬ë©ì´ ëš«ë ¤ ìžˆëŠ” ë¶€ë¶„ë¼ë¦¬ ìƒ, í•˜, ì¢Œ, ìš°ë¡œ ë¶™ì–´ ìžˆëŠ” ê²½ìš° ì„œë¡œ ì—°ê²°ë˜ì–´ ìžˆëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼í•œë‹¤. 
ì´ë•Œ ì–¼ìŒ í‹€ì˜ ëª¨ì–‘ì´ ì£¼ì–´ì¡Œì„ ë•Œ ìƒì„±ë˜ëŠ” ì´ ì•„ì´ìŠ¤í¬ë¦¼ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ëž¨ì„ ìž‘ì„±í•˜ì‹œì˜¤.

SourceCode (ìž¬ê·€í•¨ìˆ˜x dfs ì‚¬ìš©)
N, M = map(int, input().split())
dx=[0,0,-1,1]
dy=[1,-1,0,0]
graph = []
for i in range(N):
    graph.append(list(map(int, input().split())))
stack=[]
count=0
def dfs(x,y):
    if graph[x][y]!=0:
        return False
    stack.append((x,y))
    graph[x][y]=1

    while stack:
        x,y=stack.pop()
        for i in range(4):
            now_x=x+dx[i]
            now_y=y+dy[i]
            if now_x>=0 and now_x<M and now_y>=0 and now_y<N:
                if graph[now_x][now_y]==0:
                    stack.append((now_x,now_y))
                    graph[now_x][now_y]=1
    return True
for i in range(N):
    for u in range(M):
        if dfs(u,i) is True:
            count+=1
print(count)

SourceCode (ìž¬ê·€í•¨ìˆ˜x bfs ì‚¬ìš©)
from collections import deque
N, M = map(int, input().split())
dx=[0,0,-1,1]
dy=[1,-1,0,0]
graph = []
for i in range(N):
    graph.append(list(map(int, input().split())))
deq=deque()
count=0
def dfs(x,y):
    if graph[x][y]!=0:
        return False
    deq.append((x,y))
    graph[x][y]=1

    while deq:
        x,y=deq.popleft()
        for i in range(4):
            now_x=x+dx[i]
            now_y=y+dy[i]
            if now_x>=0 and now_x<M and now_y>=0 and now_y<N:
                if graph[now_x][now_y]==0:
                    deq.append((now_x,now_y))
                    graph[now_x][now_y]=1
    return True
for i in range(N):
    for u in range(M):
        if dfs(u,i) is True:
            count+=1
print(count)

SourceCode (ìž¬ê·€í•¨ìˆ˜ ì‚¬ìš©)
N, M = map(int, input().split())
dx=[0,0,-1,1]
dy=[1,-1,0,0]
graph = []
for i in range(N):
    graph.append(list(map(int, input().split())))
count=0
def dfs(x,y):
    if graph[x][y]!=0:
        return False
    graph[x][y] = 1
    for i in range(4):
        new_x = x + dx[i]
        new_y=y+ dy[i]
        if 0<=new_x and new_x<M and new_y>=0 and new_y<N:
            if graph[new_x][new_y]==0:
                dfs(new_x,new_y)
    return  True

for i in range(N):
    for u in range(M):
        if dfs(u,i) is True:
            count+=1
print(count)

ðŸ’¬ ìŒë£Œìˆ˜ ì–¼ë ¤ ë¨¹ê¸°
N x M í¬ê¸°ì˜ ì–¼ìŒ í‹€ì´ ìžˆë‹¤. êµ¬ë©ì´ ëš«ë ¤ ìžˆëŠ” ë¶€ë¶„ì€ 0, ì¹¸ë§‰ì´ê°€ ì¡´ìž¬í•˜ëŠ” ë¶€ë¶„ì€ 1ë¡œ í‘œì‹œëœë‹¤. 
êµ¬ë©ì´ ëš«ë ¤ ìžˆëŠ” ë¶€ë¶„ë¼ë¦¬ ìƒ, í•˜, ì¢Œ, ìš°ë¡œ ë¶™ì–´ ìžˆëŠ” ê²½ìš° ì„œë¡œ ì—°ê²°ë˜ì–´ ìžˆëŠ” ê²ƒìœ¼ë¡œ ê°„ì£¼í•œë‹¤. 
ì´ë•Œ ì–¼ìŒ í‹€ì˜ ëª¨ì–‘ì´ ì£¼ì–´ì¡Œì„ ë•Œ ìƒì„±ë˜ëŠ” ì´ ì•„ì´ìŠ¤í¬ë¦¼ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ëŠ” í”„ë¡œê·¸ëž¨ì„ ìž‘ì„±í•˜ì‹œì˜¤.

SourceCode (ìž¬ê·€í•¨ìˆ˜x dfs ì‚¬ìš©)
N, M = map(int, input().split())
dx=[0,0,-1,1]
dy=[1,-1,0,0]
graph = []
for i in range(N):
    graph.append(list(map(int, input().split())))
stack=[]
count=0
def dfs(x,y):
    if graph[x][y]!=0:
        return False
    stack.append((x,y))
    graph[x][y]=1

    while stack:
        x,y=stack.pop()
        for i in range(4):
            now_x=x+dx[i]
            now_y=y+dy[i]
            if now_x>=0 and now_x<M and now_y>=0 and now_y<N:
                if graph[now_x][now_y]==0:
                    stack.append((now_x,now_y))
                    graph[now_x][now_y]=1
    return True
for i in range(N):
    for u in range(M):
        if dfs(u,i) is True:
            count+=1
print(count)

SourceCode (ìž¬ê·€í•¨ìˆ˜x bfs ì‚¬ìš©)
from collections import deque
N, M = map(int, input().split())
dx=[0,0,-1,1]
dy=[1,-1,0,0]
graph = []
for i in range(N):
    graph.append(list(map(int, input().split())))
deq=deque()
count=0
def dfs(x,y):
    if graph[x][y]!=0:
        return False
    deq.append((x,y))
    graph[x][y]=1

    while deq:
        x,y=deq.popleft()
        for i in range(4):
            now_x=x+dx[i]
            now_y=y+dy[i]
            if now_x>=0 and now_x<M and now_y>=0 and now_y<N:
                if graph[now_x][now_y]==0:
                    deq.append((now_x,now_y))
                    graph[now_x][now_y]=1
    return True
for i in range(N):
    for u in range(M):
        if dfs(u,i) is True:
            count+=1
print(count)

SourceCode (ìž¬ê·€í•¨ìˆ˜ ì‚¬ìš©)
N, M = map(int, input().split())
dx=[0,0,-1,1]
dy=[1,-1,0,0]
graph = []
for i in range(N):
    graph.append(list(map(int, input().split())))
count=0
def dfs(x,y):
    if graph[x][y]!=0:
        return False
    graph[x][y] = 1
    for i in range(4):
        new_x = x + dx[i]
        new_y=y+ dy[i]
        if 0<=new_x and new_x<M and new_y>=0 and new_y<N:
            if graph[new_x][new_y]==0:
                dfs(new_x,new_y)
    return  True

for i in range(N):
    for u in range(M):
        if dfs(u,i) is True:
            count+=1
print(count)


ë¯¸ë¡œ íƒˆì¶œ
ë™ë¹ˆì´ëŠ” N x M í¬ê¸°ì˜ ì§ì‚¬ê°í˜• í˜•íƒœì˜ ë¯¸ë¡œì— ê°‡í˜€ ìžˆë‹¤. ë¯¸ë¡œì—ëŠ” ì—¬ëŸ¬ ë§ˆë¦¬ì˜ ê´´ë¬¼ì´ ìžˆì–´ ì´ë¥¼ í”¼í•´ íƒˆì¶œí•´ì•¼ í•œë‹¤. 
ë™ë¹ˆì´ì˜ ìœ„ì¹˜ëŠ” (1, 1)ì´ê³  ë¯¸ë¡œì˜ ì¶œêµ¬ëŠ” (N, M)ì˜ ìœ„ì¹˜ì— ì¡´ìž¬í•˜ë©° í•œ ë²ˆì— í•œ ì¹¸ì”© ì´ë™í•  ìˆ˜ ìžˆë‹¤. 
ì´ë•Œ ê´´ë¬¼ì´ ìžˆëŠ” ë¶€ë¶„ì€ 0ìœ¼ë¡œ, ê´´ë¬¼ì´ ì—†ëŠ” ë¶€ë¶„ì€ 1ë¡œ í‘œì‹œë˜ì–´ ìžˆë‹¤. ë¯¸ë¡œëŠ” ë°˜ë“œì‹œ íƒˆì¶œí•  ìˆ˜ ìžˆëŠ” í˜•íƒœë¡œ ì œì‹œëœë‹¤. 
ì´ë•Œ ë™ë¹ˆì´ê°€ íƒˆì¶œí•˜ê¸° ìœ„í•´ ì›€ì§ì—¬ì•¼ í•˜ëŠ” ìµœì†Œ ì¹¸ì˜ ê°œìˆ˜ë¥¼ êµ¬í•˜ì‹œì˜¤. ì¹¸ì„ ì…€ ë•ŒëŠ” ì‹œìž‘ ì¹¸ê³¼ ë§ˆì§€ë§‰ ì¹¸ì„ ëª¨ë‘ í¬í•¨í•´ì„œ ê³„ì‚°í•œë‹¤.

SourceCode (dfs):
dx=[0,0,-1,1]
dy=[1,-1,0,0]
N,M=map(int,input().split())
graph=[]
stack=[]
def dfs(x,y):
    if graph[x][y]==1:
        stack.append((x,y))

        while stack:
            x,y=stack.pop()
            for i in range(4):
                new_x=x+dx[i]
                new_y=y+dy[i]
                if new_x>=0 and new_x<M and new_y>=0 and new_y<N:
                    if graph[new_x][new_y]==1:
                        stack.append((new_x,new_y))
                        graph[new_x][new_y]=graph[x][y]+1
        return graph[M-1][N-1]
for i in range(N):
    graph.append(list(map(int,input().split())))
print(dfs(0,0))

[1260] #DFS와 BFS, 실버2  - 5/14 풀이
'''
문제
그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.

입력
첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.

출력
첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.
'''

## 코드
''' python
import sys
from collections import deque

def dfs(edge, v,visited):
    visited[v] = True   #방문자
    print(v,end=" ")
    for g in edge:  #간선 가져가기
        if v in g:  #간선에 v가 있는지 확인
            for i in range(2):
                if visited[g[i]] != True:   #간선에 연결된 노드가 True라면
                    dfs(edge, g[i], visited)    #재귀

def bfs(edge, v, visited):
    que = deque([v])
    visited[v] = True
    while que:
        s = que.popleft()
        print(s, end=' ')
        for g in edge:
            if s in g:
                for i in range(2):
                    if visited[g[i]] != True:
                        que.append(g[i])
                        visited[g[i]] = True

N, M, V = map(int, sys.stdin.readline().split())
edge = [[] for _ in range(M)]

for i in range(M):
    edge[i]=list(map(int, sys.stdin.readline().split()))

edge = sorted(edge,key= lambda x:sorted([x[0],x[1]]))   #간선을 정렬하는데 DFS의 경우 같은 위치상에 있을 때 작은 숫자부터 탐색해야 하기 때문에 2번 정렬

Visited = [False] * (N+1)   #방문자
dfs(edge,V,Visited)
print()
Visited = [False] * (N+1)   #방문자 초기화
bfs(edge,V,Visited)
'''

[2178] #미로탐색, 실버2  - 5/15 풀이
'''
문제
N×M크기의 배열로 표현되는 미로가 있다.

1	0	1	1	1	1
1	0	1	0	1	0
1	0	1	0	1	1
1	1	1	0	1	1
미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

입력
첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.

출력
첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.
'''

## 코드
from collections import deque

def bfs(x,y):
    que = deque()
    que.append((x, y))

    while que:
        x,y = que.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or ny < 0 or nx >= N or ny >= M:
                continue
            if graph[nx][ny] == 1:
                graph[nx][ny] = graph[x][y] + 1
                que.append((nx, ny))

    return graph[N-1][M-1]

N, M = map(int, input().split())
graph = []
for i in range(N):
    graph.append(list(map(int, input())))

dx = [-1,1,0,0]
dy = [0,0,-1,1]

print(bfs(0, 0))

2606] #바이러스, 실버3  - 5/16 풀이
'''
문제
신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.

예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.



어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.

입력
첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다.

출력
1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.
'''


## 코드
import sys
from collections import deque

def dfs(edge, v,visited):
    visited[v] = True
    #print(v,end=" ")
    for g in edge:
        if v in g:
            for i in range(2):
                if visited[g[i]] != True:
                    dfs(edge, g[i], visited)

def bfs(edge, v, visited):
    que = deque([v])
    visited[v] = True
    while que:
        s = que.popleft()
        #print(s, end=' ')
        for g in edge:
            if s in g:
                for i in range(2):
                    if visited[g[i]] != True:
                        que.append(g[i])
                        visited[g[i]] = True

N = int(sys.stdin.readline())
K = int(sys.stdin.readline())
edge = [[] for _ in range(K)]

for i in range(K):
    edge[i]=list(map(int, sys.stdin.readline().split()))

edge = sorted(edge,key= lambda x:[x[0],x[1]])

Visited = [False] * (N+1)
dfs(edge,1,Visited)

print(Visited.count(True) - 1)

7576] #토마토, 실버1  - 5/17 풀이, 코드 길이 줄이기
'''
문제
철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다. 



창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.

토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.

입력
첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.

토마토가 하나 이상 있는 경우만 입력으로 주어진다.

출력
여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.
'''

## 코드
import sys
from collections import deque

def Search_1(x,y):
    if graph[x][y] == 1:
        return True
    return False

def bfs(tmp):
    que = deque()
    for i in range(len(tmp)):
        que.append(tmp[i])
    while que:
        x,y = que.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or nx >= N or ny < 0 or ny >= M:
                continue

            if graph[nx][ny] == -1:
                continue

            if graph[nx][ny] == 0:
                graph[nx][ny] = graph[x][y] + 1
                que.append((nx, ny))


M,N = map(int,sys.stdin.readline().split())

dx = [-1,1,0,0]
dy = [0,0,-1,1]
graph = [[] for _ in range(N)]

for i in range(N):
    graph[i] = list(map(int, sys.stdin.readline().split()))

tmp = []

for i in range(N):
    for j in range(M):
        if Search_1(i,j) is True:
            tmp.append((i,j))

c= 0
for i in range(N):
    if 0 not in graph[i]:
        c += 1

if c == N:
    print(0)

else:
    bfs(tmp)

    for i in range(N):
        if 0 in graph[i]:
            print(-1)
            break

    else:
        res = [i for i in range(N)]
        for i in range(N):
            res[i] = max(graph[i])

        res.sort()
        print(res[-1] - 1)
